--value@karaokeText:字幕,"ここに[歌][詞]を[入][力]します"
--value@karaokeRuby:ルビ,"[か][し][にゅう][りょく]"
--value@karaokeTime:変化時間比率,"11111122111"
--value@fakeText:嘘字幕,""
--value@fakeRuby:嘘ルビ,""

--track@rubySizeRatio:ルビ倍率,0,100,40,1
--track@rubyX:ルビ位置X,-1000,1000,0,0.01
--track@rubyY:ルビ位置Y,-1000,1000,0,0.01
--track@progress:変化度,0,100,30,0.1

--color@bgInnerColor:変化前文字色,0xFFFFFF
--color@bgOuterColor:変化前輪郭色,0x000000
--color@fgInnerColor:変化後文字色,0x0000FF
--color@fgOuterColor:変化後輪郭色,0xFFFFFF

--select@textAlign:配置=4,左寄せ[上]=0,中央揃え[上]=1,右寄せ[上]=2,左寄せ[中]=3,中央揃え[中]=4,右寄せ[中]=5,左寄せ[下]=6,中央揃え[下]=7,右寄せ[下]=8
--select@fakeAlign:嘘字幕配置=0,左寄せ=0,中央揃え=1,右寄せ=2
--font@font:フォント,Meiryo UI
--track@fontSize:フォントサイズ,1,400,120,1
--check@isBold:太字,true
--check@isItalic:斜体,false
--select@decoration:文字修飾=3,標準文字=0,影付き文字=1,影付き文字（薄）=2,縁取り文字=3,縁取り文字（細）=4,縁取り文字（太）=5,縁取り文字（角）=6

--check@kerningMode:字間機能を使う,false
--track@kerning:字間,-100,100,0,1

--check@showGuide:ガイドを表示,true



------ 定数定義
-- 制御文字
local GROUP_BEGIN1 = "["	-- ルビグループの開始記号1
local GROUP_BEGIN2 = "{"	-- ルビグループの開始記号2
local GROUP_END1 = "]"	-- ルビグループの終了記号1
local GROUP_END2 = "}"	-- ルビグループの終了記号2
local CONNECTOR = "_"	-- 複数コードポイントを纏めて1文字として扱うときの結合子
local ESCAPE = "%"	-- エスケープ記号


-- 既定値等
local DEFAULT_TIME_BEATS = 5	-- 既定の変化時間比率
local MARGIN_X = 10	-- 仮想バッファのマージン（横方向）
local MARGIN_Y = 5	-- 仮想バッファのマージン（縦方向）
local ERROR_MESSAGE = "エラー"	-- 入力値不正時の代替文字列


-- ガイドのフォント
local FONT_GUIDE = { "MS UI Gothic", 20, 4, 0xFF8080, 0x000000 }



------ 関数定義
-- UTF-8文字列を文字毎に分割して配列化
function stringToCharArray(str)
	if str == "" then
		return {}
	end

	local ret = {}
	local ptr = 0
	for i = 1, string.len(str) do
		local byte = string.byte(str, i)
		if byte <= 0x7F or byte >= 0xC0 then
			if ptr > 0 then
				ret[#ret + 1] = string.sub(str, ptr, i - 1)
			end
			ptr = i
		end
	end
	ret[#ret + 1] = string.sub(str, ptr)

	return ret
end


-- UTF-8文字列をパース
function parseString(str)
	-- 返り値
	local chars = {}	-- 文字列を文字毎に分割して配列化にしたもの
	local groupPositions = {}	-- 各ルビグループの { 開始位置, 終了位置, 開始記号, 終了記号 } の4つ組を並べた配列

	-- 字句読込モード
	local isFollowingToEscape = false
	local isFollowingToConnector = false
	local allowConnector = false
	local beginningPosition = nil
	local beginningChar = nil

	-- パース
	local raw = stringToCharArray(str)
	for i = 1, #raw do
		if isFollowingToEscape then
			if isFollowingToConnector then
				chars[#chars] = chars[#chars] .. raw[i]
				isFollowingToConnector = false
			else
				chars[#chars + 1] = raw[i]
			end
			allowConnector = true
			isFollowingToEscape = false
		elseif raw[i] == ESCAPE then
			isFollowingToEscape = true
		elseif raw[i] == CONNECTOR then
			if not allowConnector then
				return nil, nil	-- 結合子が連続している
			end
			isFollowingToConnector = true
			allowConnector = false
		elseif raw[i] == GROUP_BEGIN1 or raw[i] == GROUP_BEGIN2 then
			if beginningPosition then
				return nil, nil	-- ルビグループの中でルビグループを開始しようとしている
			end
			beginningPosition = #chars + 1
			beginningChar = raw[i]
			isFollowingToConnector = false
			allowConnector = false
		elseif raw[i] == GROUP_END1 or raw[i] == GROUP_END2 then
			if not beginningPosition then
				return nil, nil	-- 開始していないルビグループを終了しようとしている
			end
			groupPositions[#groupPositions + 1] = { beginningPosition, #chars, beginningChar, raw[i] }
			beginningPosition = nil
			beginningChar = nil
			isFollowingToConnector = false
			allowConnector = false
		else
			if isFollowingToConnector then
				chars[#chars] = chars[#chars] .. raw[i]
				isFollowingToConnector = false
			else
				chars[#chars + 1] = raw[i]
			end
			allowConnector = true
		end
	end

	if isFollowingToEscape or isFollowingToConnector or beginningPosition then
		return nil, nil	-- エスケープ記号/結合子/ルビグループが完了していない
	end
	return chars, groupPositions
end



------ 事前処理
-- 出力モードの判定
showGuide = showGuide and not obj.getinfo("saving")



------ メイン処理
function main()
	---- 文字列のパース
	-- 背景メインテキスト
	local bgTexts, bgRubyPositions = parseString(karaokeText)
	if not bgTexts then
		bgTexts, bgRubyPositions = stringToCharArray(ERROR_MESSAGE), {}
	end


	-- 背景ルビ
	local bgRubys = {}
	local tmp1, tmp2 = parseString(karaokeRuby)
	if tmp1 then
		for i = 1, #tmp2 do
			bgRubys[i] = {unpack(tmp1, tmp2[i][1], tmp2[i][2])}
		end
	else
		errMsg = stringToCharArray(ERROR_MESSAGE)
		for i = 1, #bgRubyPositions do
			bgRubys[i] = errMsg
		end
	end


	-- 前景メインテキスト
	local fgTexts = bgTexts
	local fgRubyPositions = bgRubyPositions
	if fakeText ~= "" then
		fgTexts, fgRubyPositions = parseString(fakeText)
		if not fgTexts then
			fgTexts, fgRubyPositions = stringToCharArray(ERROR_MESSAGE), {}
		end
	end


	-- 前景ルビ
	local fgRubys = bgRubys
	if fakeRuby ~= "" then
		fgRubys = {}
		tmp1, tmp2 = parseString(fakeRuby)
		if tmp1 then
			for i = 1, #tmp2 do
				fgRubys[i] = {unpack(tmp1, tmp2[i][1], tmp2[i][2])}
			end
		else
			errMsg = stringToCharArray(ERROR_MESSAGE)
			for i = 1, #fgRubyPositions do
				fgRubys[i] = errMsg
			end
		end
	end


	-- 変化時間比率
	local timeBeats = {}
	for i = 1, string.len(karaokeTime) do
		timeBeats[#timeBeats + 1] = string.byte(karaokeTime, i) - 0x30
	end



	---- 各文字の幅を取得
	local textPrefix = "<s,," .. (isBold and "B" or "") .. (isItalic and "I" or "") .. ">"
	local bgCharWidths = {}
	local bgRubyWidths = {}
	local fgCharWidths = {}
	local fgRubyWidths = {}


	-- 字間の設定
	local kernControl = ""
	if kerningMode then
		kernControl = ((kerning >= 0) and "<p+" or "<p") .. tostring(kerning) .. ",+0>"
	else
		kerning = 0
	end


	-- 背景メインテキスト幅
	obj.setfont(font, fontSize, decoration)
	local tmpWidths = {}
	for i = 1, #bgTexts do
		obj.load("text", textPrefix .. table.concat({unpack(bgTexts, i)}, kernControl))
		tmpWidths[i] = obj.w
	end
	tmpWidths[#bgTexts + 1] = 0
	for i = 1, #bgTexts do
		bgCharWidths[i] = tmpWidths[i] - tmpWidths[i + 1]
	end
	local bgTextWidth = tmpWidths[1]


	-- 前景メインテキスト幅
	for i = 1, #fgTexts do
		obj.load("text", textPrefix .. table.concat({unpack(fgTexts, i)}, kernControl))
		tmpWidths[i] = obj.w
	end
	tmpWidths[#fgTexts + 1] = 0
	for i = 1, #fgTexts do
		fgCharWidths[i] = tmpWidths[i] - tmpWidths[i + 1]
	end
	local fgTextWidth = tmpWidths[1]


	-- メインテキスト高さ
	obj.load("text", textPrefix .. table.concat(bgTexts, "") .. table.concat(fgTexts, ""))
	local textHeight = obj.h


	-- 背景ルビ
	local rubySize = math.ceil(fontSize * rubySizeRatio * 0.01)
	local rubyHeight = 0
	obj.setfont(font, rubySize, decoration)
	for i = 1, #bgRubys do
		obj.load("text", textPrefix .. table.concat(bgRubys[i], ""))
		bgRubyWidths[i] = obj.w
		rubyHeight = math.max(rubyHeight, obj.h)
	end


	-- 前景ルビ
	for i = 1, #fgRubys do
		obj.load("text", textPrefix .. table.concat(fgRubys[i], ""))
		fgRubyWidths[i] = obj.w
		rubyHeight = math.max(rubyHeight, obj.h)
	end



	---- 仮想バッファサイズ計算
	local textWidth = math.max(bgTextWidth, fgTextWidth)
	local marginWidth = MARGIN_X * 2 + math.max(
		(bgRubyWidths[1] or 0) - (bgCharWidths[1] or 0) - rubyX,
		(fgRubyWidths[1] or 0) - (fgCharWidths[1] or 0) - rubyX,
		(bgRubyWidths[#bgRubyWidths] or 0) - (bgCharWidths[#bgCharWidths] or 0) + rubyX,
		(fgRubyWidths[#fgRubyWidths] or 0) - (fgCharWidths[#fgCharWidths] or 0) + rubyX,
		0
	)
	local bufferWidth = textWidth + marginWidth * 2
	local bufferHeight = textHeight + 2 * (MARGIN_Y + math.max(0, rubyHeight - rubyY, rubyY - textHeight, FONT_GUIDE[2] * 2))



	---- クリッピング位置計算
	-- 背景/前景のうち長い方のメインテキストを対象とする
	local bgIsLonger = (bgTextWidth > fgTextWidth)
	local len = bgIsLonger and #bgTexts or #fgTexts
	local charWidths = (bgIsLonger and bgCharWidths or fgCharWidths)

	-- 対象メインテキストの左端位置
	local startPosition = -textWidth / 2
	local clipping = startPosition + textWidth * progress / 100

	-- 未指定の変化時間比率を既定値で埋める
	for i = #timeBeats + 1, len do
		timeBeats[i] = DEFAULT_TIME_BEATS
	end

	-- 変化度が 0 や 100 のときはマージン分を補正する
	if progress <= 0 then
		clipping = startPosition - marginWidth
	elseif progress >= 100 then
		clipping = startPosition + textWidth + marginWidth

	-- それ以外でかつメインテキストが空でない場合は文字毎の変化時間比率に基づいて位置を決める
	elseif len > 0 then
		-- 変化時間比率の総和
		local timeBeatsSum = 0
		for i = 1, len do
			timeBeatsSum = timeBeatsSum + timeBeats[i]
		end

		-- クリッピング位置がどの文字に在るか
		local i = 1
		local timeBeatsAccum = 0
		local clippedCharLeft = startPosition
		while timeBeatsSum * progress > (timeBeatsAccum + timeBeats[i]) * 100 do
			timeBeatsAccum = timeBeatsAccum + timeBeats[i]
			clippedCharLeft = clippedCharLeft + charWidths[i]
			i = i + 1
		end
		local clippedCharRatio = (timeBeatsSum * progress / 100 - timeBeatsAccum) / timeBeats[i]

		-- クリッピング位置
		clipping = clippedCharLeft + charWidths[i] * clippedCharRatio
	end


	---- 背景描画
	obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)


	-- 背景メインテキストの左端位置
	startPosition =
		(fakeAlign == 0) and -textWidth / 2                   or	-- 嘘字幕左寄せ
		(fakeAlign == 2) and  textWidth / 2 - bgTextWidth     or	-- 嘘字幕右寄せ
		                                    - bgTextWidth / 2   	-- 嘘字幕中央揃え


	-- 背景メインテキスト
	obj.setfont(font, fontSize, decoration, bgInnerColor, bgOuterColor)
	local position = startPosition
	obj.load("text", textPrefix .. table.concat(bgTexts, kernControl))
	obj.draw(position + bgTextWidth / 2, 0)


	-- 背景ルビ
	obj.setfont(font, rubySize, decoration, bgInnerColor, bgOuterColor)
	for i = 1, #bgRubyPositions do
		if bgRubys[i] and #bgRubys[i] > 0 then
			-- ルビ対象文字列の左端
			local leftmost = startPosition
			for j = 1, bgRubyPositions[i][1] - 1 do
				leftmost = leftmost + bgCharWidths[j]
			end

			-- ルビ対象文字列の右端
			local rightmost = leftmost
			for j = bgRubyPositions[i][1], bgRubyPositions[i][2] do
				rightmost = rightmost + bgCharWidths[j]
			end
			if bgRubyPositions[i][2] < #bgTexts then
				rightmost = rightmost - kerning
			end

			-- ルビの幅
			obj.load("text", textPrefix .. table.concat(bgRubys[i], ""))
			local rubyWidth = obj.w

			-- ルビ描画位置
			local rubyPosition = (leftmost + rightmost) / 2
			local rubyKernControl = ""
			if bgRubyPositions[i][3] == GROUP_BEGIN1 and bgRubyPositions[i][4] == GROUP_END1 then	-- 中央揃え
				-- do nothing
			elseif bgRubyPositions[i][3] == GROUP_BEGIN2 and bgRubyPositions[i][4] == GROUP_END1 then	-- 左寄せ
				rubyPosition = leftmost + rubyWidth / 2
			elseif bgRubyPositions[i][3] == GROUP_BEGIN1 and bgRubyPositions[i][4] == GROUP_END2 then	-- 右寄せ
				rubyPosition = rightmost - rubyWidth / 2
			elseif #bgRubys[i] > 1 then	-- 均等割り付け
				local rubyKerning = (rightmost - leftmost - rubyWidth) / (#bgRubys[i] - 1)
				rubyKernControl = ((rubyKerning >= 0) and "<p+" or "<p") .. tostring(rubyKerning) .. ",+0>"
			end

			-- ルビ描画
			obj.load("text", textPrefix .. table.concat(bgRubys[i], rubyKernControl))
			obj.draw(rubyPosition + rubyX, rubyY - (textHeight + rubyHeight) / 2)
		end
	end


	-- 背景をキャッシュに退避
	obj.copybuffer("cache:background", "tempbuffer")



	---- 前景描画
	obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)


	-- 前景メインテキストの左端位置
	startPosition =
		(fakeAlign == 0) and -textWidth / 2                   or	-- 嘘字幕左寄せ
		(fakeAlign == 2) and  textWidth / 2 - fgTextWidth     or	-- 嘘字幕右寄せ
		                                    - fgTextWidth / 2   	-- 嘘字幕中央揃え


	-- 前景メインテキスト
	obj.setfont(font, fontSize, decoration, fgInnerColor, fgOuterColor)
	local position = startPosition
	obj.load("text", textPrefix .. table.concat(fgTexts, kernControl))
	obj.draw(position + fgTextWidth / 2, 0)


	-- 前景ルビ
	obj.setfont(font, rubySize, decoration, fgInnerColor, fgOuterColor)
	for i = 1, #fgRubyPositions do
		if fgRubys[i] and #fgRubys[i] > 0 then
			-- ルビ対象文字列の左端
			local leftmost = startPosition
			for j = 1, fgRubyPositions[i][1] - 1 do
				leftmost = leftmost + fgCharWidths[j]
			end

			-- ルビ対象文字列の右端
			local rightmost = leftmost
			for j = fgRubyPositions[i][1], fgRubyPositions[i][2] do
				rightmost = rightmost + fgCharWidths[j]
			end
			if fgRubyPositions[i][2] < #fgTexts then
				rightmost = rightmost - kerning
			end

			-- ルビの幅
			obj.load("text", textPrefix .. table.concat(fgRubys[i], ""))
			local rubyWidth = obj.w

			-- ルビ描画位置
			local rubyPosition = (leftmost + rightmost) / 2
			local rubyKernControl = ""
			if fgRubyPositions[i][3] == GROUP_BEGIN1 and fgRubyPositions[i][4] == GROUP_END1 then	-- 中央揃え
				-- do nothing
			elseif fgRubyPositions[i][3] == GROUP_BEGIN2 and fgRubyPositions[i][4] == GROUP_END1 then	-- 左寄せ
				rubyPosition = leftmost + rubyWidth / 2
			elseif fgRubyPositions[i][3] == GROUP_BEGIN1 and fgRubyPositions[i][4] == GROUP_END2 then	-- 右寄せ
				rubyPosition = rightmost - rubyWidth / 2
			elseif #fgRubys[i] > 1 then	-- 均等割り付け
				local rubyKerning = (rightmost - leftmost - rubyWidth) / (#fgRubys[i] - 1)
				rubyKernControl = ((rubyKerning >= 0) and "<p+" or "<p") .. tostring(rubyKerning) .. ",+0>"
			end

			-- ルビ描画
			obj.load("text", textPrefix .. table.concat(fgRubys[i], rubyKernControl))
			obj.draw(rubyPosition + rubyX, rubyY - (textHeight + rubyHeight) / 2)
		end
	end


	-- 前景をキャッシュに退避
	obj.copybuffer("cache:foreground", "tempbuffer")



	---- ガイド描画
	if showGuide then
		obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)
		
		-- 対象メインテキストの左端位置
		startPosition = -textWidth / 2

		-- 変化時間比率描画
		obj.setfont(unpack(FONT_GUIDE))
		position = startPosition
		for i = 1, len do
			obj.load("text", tostring(timeBeats[i]))
			obj.draw(position + (charWidths[i] - ((i < len) and kerning or 0)) / 2, (textHeight + FONT_GUIDE[2]) / 2)
			position = position + charWidths[i]
		end
		obj.load("text", "変化時間比率")
		obj.draw(startPosition + textWidth / 2, (textHeight + FONT_GUIDE[2] * 3) / 2)

		-- ガイドをキャッシュに退避
		obj.copybuffer("cache:guide", "tempbuffer")
	end



	---- 背景と前景とガイドとを合体
	obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)


	-- 背景描画
	obj.copybuffer("object", "cache:background")
	obj.effect("クリッピング", "左", bufferWidth / 2 + clipping)
	obj.draw((bufferWidth / 2 + clipping) / 2)


	-- 前景描画
	obj.copybuffer("object", "cache:foreground")
	obj.effect("クリッピング", "右", bufferWidth / 2 - clipping)
	obj.draw(-(bufferWidth / 2 - clipping) / 2)


	-- ガイド描画
	if showGuide then
		obj.copybuffer("object", "cache:guide")
		obj.draw()
	end



	---- 描画・水平配置調整
	obj.load("tempbuffer")
	obj.cx = (textAlign % 3 - 1) * textWidth / 2
	obj.cy = (math.floor(textAlign / 3) - 1) * textHeight / 2
end


main()
