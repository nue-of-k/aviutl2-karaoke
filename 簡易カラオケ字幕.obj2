--value@karaokeText:字幕,"ここに[歌][詞]を[入][力]します"
--value@karaokeRuby:ルビ,"[か][し][にゅう][りょく]"
--value@karaokeTime:変化時間比率,"11111122111"
--value@fakeText:嘘字幕,""
--value@fakeRuby:嘘ルビ,""

--track@rubySizeRatio:ルビ倍率,0,100,40,1
--track@rubyX:ルビ位置X,-1000,1000,0,0.01
--track@rubyY:ルビ位置Y,-1000,1000,0,0.01
--track@progress:変化度,0,100,30,0.1

--color@bgInnerColor:変化前文字色,0xFFFFFF
--color@bgOuterColor:変化前輪郭色,0x000000
--color@fgInnerColor:変化後文字色,0x0000FF
--color@fgOuterColor:変化後輪郭色,0xFFFFFF

--select@textAlign:配置=4,左寄せ[上]=0,中央揃え[上]=1,右寄せ[上]=2,左寄せ[中]=3,中央揃え[中]=4,右寄せ[中]=5,左寄せ[下]=6,中央揃え[下]=7,右寄せ[下]=8
--select@fakeAlign:嘘字幕配置=0,左寄せ=0,中央揃え=1,右寄せ=2
--font@font:フォント,Meiryo UI
--track@fontSize:フォントサイズ,1,400,120,1
--check@isBold:太字,true
--check@isItalic:斜体,false
--select@decoration:文字修飾=3,標準文字=0,影付き文字=1,影付き文字（薄）=2,縁取り文字=3,縁取り文字（細）=4,縁取り文字（太）=5,縁取り文字（角）=6

--check@kerningMode:字間機能を使う,false
--track@kerning:字間,-100,100,0,1

--check@showGuide:ガイドを表示,true



------ 定数定義
-- 制御文字
local GROUP_BEGIN = "["	-- ルビグループの開始記号
local GROUP_END = "]"	-- ルビグループの終了記号
local CONNECTOR = "_"	-- 複数コードポイントを纏めて1文字として扱うときの結合子
local ESCAPE = "%"	-- エスケープ記号


-- 既定値等
local DEFAULT_TIME_BEATS = 5	-- 既定の変化時間比率
local MARGIN_X = 10	-- 仮想バッファのマージン（横方向）
local MARGIN_Y = 5	-- 仮想バッファのマージン（縦方向）


-- ガイドのフォント
local FONT_GUIDE = { "MS UI Gothic", 20, 4, 0xFF8080, 0x000000 }



------ 関数定義
-- UTF-8文字列を文字毎に分割して配列化
function stringToArray(str)
	if str == "" then
		return {}
	end

	local ret = {}
	local ptr = 0
	for i = 1, string.len(str) do
		local byte = string.byte(str, i)
		if byte <= 0x7F or byte >= 0xC0 then
			if ptr > 0 then
				ret[#ret + 1] = string.sub(str, ptr, i - 1)
			end
			ptr = i
		end
	end
	ret[#ret + 1] = string.sub(str, ptr)

	return ret
end



------ 事前処理
-- 出力モードの判定
showGuide = showGuide and not obj.getinfo("saving")



------ メイン処理
function main()
	---- 文字列のパース
	-- 背景メインテキスト
	local bgTexts = {}	-- 背景メインテキストを文字毎に分けて配列にしたもの
	local bgRubyPositions = {}	-- 背景ルビグループの開始位置・終了位置の組からなる配列
	local tmp = stringToArray(karaokeText)
	local isFollowingToEscape = false
	local isFollowingToConnector = false
	local ptr = 1
	for i = 1, #tmp do
		if isFollowingToEscape and isFollowingToConnector then
			bgTexts[#bgTexts] = bgTexts[#bgTexts] .. tmp[i]
			isFollowingToEscape = false
			isFollowingToConnector = false
		elseif isFollowingToEscape then
			bgTexts[#bgTexts + 1] = tmp[i]
			isFollowingToEscape = false
		elseif tmp[i] == ESCAPE then
			isFollowingToEscape = true
		elseif tmp[i] == CONNECTOR then
			isFollowingToConnector = true
		elseif tmp[i] == GROUP_BEGIN then
			ptr = #bgTexts + 1
			isFollowingToConnector = false
		elseif tmp[i] == GROUP_END then
			bgRubyPositions[#bgRubyPositions + 1] = { ptr, #bgTexts }
			isFollowingToConnector = false
		elseif isFollowingToConnector then
			bgTexts[#bgTexts] = bgTexts[#bgTexts] .. tmp[i]
			isFollowingToConnector = false
		else
			bgTexts[#bgTexts + 1] = tmp[i]
		end
	end


	-- 背景ルビ
	local bgRubys = {}	-- 背景ルビ文字列の配列
	tmp = stringToArray(karaokeRuby)
	isFollowingToEscape = false
	local inGroup = false
	for i = 1, #tmp do
		if not isFollowingToEscape and tmp[i] == GROUP_BEGIN then
			bgRubys[#bgRubys + 1] = ""
			inGroup = true
		elseif not isFollowingToEscape and tmp[i] == GROUP_END then
			inGroup = false
		elseif not isFollowingToEscape and tmp[i] == ESCAPE then
			isFollowingToEscape = true
		elseif inGroup then
			bgRubys[#bgRubys] = bgRubys[#bgRubys] .. tmp[i]
			isFollowingToEscape = false
		else
			isFollowingToEscape = false
		end
	end


	-- 前景メインテキスト
	local fgTexts = {}	-- 前景メインテキストを文字毎に分けて配列にしたもの
	local fgRubyPositions = {}	-- 前景ルビグループの開始位置・終了位置の組からなる配列
	if fakeText == "" then
		fgTexts = bgTexts
		fgRubyPositions = bgRubyPositions
	else
		tmp = stringToArray(fakeText)
		isFollowingToEscape = false
		isFollowingToConnector = false
		ptr = 1
		for i = 1, #tmp do
			if isFollowingToEscape and isFollowingToConnector then
				fgTexts[#fgTexts] = fgTexts[#fgTexts] .. tmp[i]
				isFollowingToEscape = false
				isFollowingToConnector = false
			elseif isFollowingToEscape then
				fgTexts[#fgTexts + 1] = tmp[i]
				isFollowingToEscape = false
			elseif tmp[i] == ESCAPE then
				isFollowingToEscape = true
			elseif tmp[i] == CONNECTOR then
				isFollowingToConnector = true
			elseif tmp[i] == GROUP_BEGIN then
				ptr = #fgTexts + 1
				isFollowingToConnector = false
			elseif tmp[i] == GROUP_END then
				fgRubyPositions[#fgRubyPositions + 1] = { ptr, #fgTexts }
				isFollowingToConnector = false
			elseif isFollowingToConnector then
				fgTexts[#fgTexts] = fgTexts[#fgTexts] .. tmp[i]
				isFollowingToConnector = false
			else
				fgTexts[#fgTexts + 1] = tmp[i]
			end
		end
	end


	-- 前景ルビ
	local fgRubys = {}	-- 前景ルビ文字列の配列
	if fakeRuby == "" then
		fgRubys = bgRubys
	else
		tmp = stringToArray(fakeRuby)
		isFollowingToEscape = false
		inGroup = false
		for i = 1, #tmp do
			if not isFollowingToEscape and tmp[i] == GROUP_BEGIN then
				fgRubys[#fgRubys + 1] = ""
				inGroup = true
			elseif not isFollowingToEscape and tmp[i] == GROUP_END then
				inGroup = false
			elseif not isFollowingToEscape and tmp[i] == ESCAPE then
				isFollowingToEscape = true
			elseif inGroup then
				fgRubys[#fgRubys] = fgRubys[#fgRubys] .. tmp[i]
				isFollowingToEscape = false
			else
				isFollowingToEscape = false
			end
		end
	end


	-- 変化時間比率
	local timeBeats = {}
	for i = 1, string.len(karaokeTime) do
		timeBeats[#timeBeats + 1] = string.byte(karaokeTime, i) - 0x30
	end



	---- 各文字の幅を取得
	local textPrefix = "<s,," .. (isBold and "B" or "") .. (isItalic and "I" or "") .. ">"
	local bgCharWidths = {}
	local bgRubyWidths = {}
	local fgCharWidths = {}
	local fgRubyWidths = {}


	-- 字間の設定
	local kernControl = ""
	if kerningMode then
		kernControl = ((kerning >= 0) and "<p+" or "<p") .. tostring(kerning) .. ",+0>"
	else
		kerning = 0
	end


	-- 背景メインテキスト幅
	obj.setfont(font, fontSize, decoration)
	local tmpWidths = {}
	for i = 1, #bgTexts do
		obj.load("text", textPrefix .. table.concat({unpack(bgTexts, i)}, kernControl))
		tmpWidths[i] = obj.w
	end
	tmpWidths[#bgTexts + 1] = 0
	for i = 1, #bgTexts do
		bgCharWidths[i] = tmpWidths[i] - tmpWidths[i + 1]
	end
	local bgTextWidth = tmpWidths[1]


	-- 前景メインテキスト幅
	for i = 1, #fgTexts do
		obj.load("text", textPrefix .. table.concat({unpack(fgTexts, i)}, kernControl))
		tmpWidths[i] = obj.w
	end
	tmpWidths[#fgTexts + 1] = 0
	for i = 1, #fgTexts do
		fgCharWidths[i] = tmpWidths[i] - tmpWidths[i + 1]
	end
	local fgTextWidth = tmpWidths[1]


	-- メインテキスト高さ
	obj.load("text", textPrefix .. table.concat(bgTexts, "") .. table.concat(fgTexts, ""))
	local textHeight = obj.h


	-- 背景ルビ
	local rubySize = math.ceil(fontSize * rubySizeRatio * 0.01)
	obj.setfont(font, rubySize, decoration)
	for i = 1, #bgRubys do
		obj.load("text", textPrefix .. bgRubys[i])
		bgRubyWidths[i] = obj.w
	end


	-- 前景ルビ
	for i = 1, #fgRubys do
		obj.load("text", textPrefix .. fgRubys[i])
		fgRubyWidths[i] = obj.w
	end


	-- ルビ高さ
	obj.load("text", textPrefix .. table.concat(bgRubys, "") .. table.concat(fgRubys, ""))
	local rubyHeight = obj.h



	---- 仮想バッファサイズ計算
	local textWidth = math.max(bgTextWidth, fgTextWidth)
	local marginWidth = MARGIN_X * 2 + math.max(
		((bgRubyWidths[1] or 0) - (bgCharWidths[1] or 0)) / 2 - rubyX,
		((fgRubyWidths[1] or 0) - (fgCharWidths[1] or 0)) / 2 - rubyX,
		((bgRubyWidths[#bgRubyWidths] or 0) - (bgCharWidths[#bgCharWidths] or 0)) / 2 + rubyX,
		((fgRubyWidths[#fgRubyWidths] or 0) - (fgCharWidths[#fgCharWidths] or 0)) / 2 + rubyX,
		0
	)
	local bufferWidth = textWidth + marginWidth * 2
	local bufferHeight = textHeight + 2 * (MARGIN_Y + math.ceil(math.abs(rubyY)) + math.max(rubyHeight, FONT_GUIDE[2] * 2))



	---- クリッピング位置計算
	-- 背景/前景のうち長い方のメインテキストを対象とする
	local bgIsLonger = (bgTextWidth > fgTextWidth)
	local len = bgIsLonger and #bgTexts or #fgTexts
	local charWidths = (bgIsLonger and bgCharWidths or fgCharWidths)

	-- 対象メインテキストの左端位置
	local startPosition = -textWidth / 2
	local clipping = startPosition + textWidth * progress / 100

	-- 未指定の変化時間比率を既定値で埋める
	for i = #timeBeats + 1, len do
		timeBeats[i] = DEFAULT_TIME_BEATS
	end

	-- 変化度が 0 や 100 のときはマージン分を補正する
	if progress <= 0 then
		clipping = startPosition - marginWidth
	elseif progress >= 100 then
		clipping = startPosition + textWidth + marginWidth

	-- それ以外でかつメインテキストが空でない場合は文字毎の変化時間比率に基づいて位置を決める
	elseif len > 0 then
		-- 変化時間比率の総和
		local timeBeatsSum = 0
		for i = 1, len do
			timeBeatsSum = timeBeatsSum + timeBeats[i]
		end

		-- クリッピング位置がどの文字に在るか
		local i = 1
		local timeBeatsAccum = 0
		local clippedCharLeft = startPosition
		while timeBeatsSum * progress > (timeBeatsAccum + timeBeats[i]) * 100 do
			timeBeatsAccum = timeBeatsAccum + timeBeats[i]
			clippedCharLeft = clippedCharLeft + charWidths[i]
			i = i + 1
		end
		local clippedCharRatio = (timeBeatsSum * progress / 100 - timeBeatsAccum) / timeBeats[i]

		-- クリッピング位置
		clipping = clippedCharLeft + charWidths[i] * clippedCharRatio
	end


	---- 背景描画
	obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)


	-- 背景メインテキストの左端位置
	startPosition =
		(fakeAlign == 0) and -textWidth / 2                   or	-- 嘘字幕左寄せ
		(fakeAlign == 2) and  textWidth / 2 - bgTextWidth     or	-- 嘘字幕右寄せ
		                                    - bgTextWidth / 2   	-- 嘘字幕中央揃え


	-- 背景メインテキスト
	obj.setfont(font, fontSize, decoration, bgInnerColor, bgOuterColor)
	local position = startPosition
	obj.load("text", textPrefix .. table.concat(bgTexts, kernControl))
	obj.draw(position + bgTextWidth / 2, 0)


	-- 背景ルビ
	obj.setfont(font, rubySize, decoration, bgInnerColor, bgOuterColor)
	for i = 1, #bgRubyPositions do
		-- ルビ対象文字列の左端
		local leftmost = startPosition
		for j = 1, bgRubyPositions[i][1] - 1 do
			leftmost = leftmost + bgCharWidths[j]
		end

		-- ルビ対象文字列の右端
		local rightmost = leftmost
		for j = bgRubyPositions[i][1], bgRubyPositions[i][2] do
			rightmost = rightmost + bgCharWidths[j]
		end
		if bgRubyPositions[i][2] < #bgTexts then
			rightmost = rightmost - kerning
		end

		-- ルビ描画
		if bgRubys[i] and bgRubys[i] ~= "" then
			obj.load("text", textPrefix .. bgRubys[i])
			obj.draw((leftmost + rightmost) / 2, rubyY - (textHeight + rubyHeight) / 2)
		end
	end


	-- 背景をキャッシュに退避
	obj.copybuffer("cache:background", "tempbuffer")



	---- 前景描画
	obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)


	-- 前景メインテキストの左端位置
	startPosition =
		(fakeAlign == 0) and -textWidth / 2                   or	-- 嘘字幕左寄せ
		(fakeAlign == 2) and  textWidth / 2 - fgTextWidth     or	-- 嘘字幕右寄せ
		                                    - fgTextWidth / 2   	-- 嘘字幕中央揃え


	-- 前景メインテキスト
	obj.setfont(font, fontSize, decoration, fgInnerColor, fgOuterColor)
	local position = startPosition
	obj.load("text", textPrefix .. table.concat(fgTexts, kernControl))
	obj.draw(position + fgTextWidth / 2, 0)


	-- 前景ルビ
	obj.setfont(font, rubySize, decoration, fgInnerColor, fgOuterColor)
	for i = 1, #fgRubyPositions do
		-- ルビ対象文字列の左端
		local leftmost = startPosition
		for j = 1, fgRubyPositions[i][1] - 1 do
			leftmost = leftmost + fgCharWidths[j]
		end

		-- ルビ対象文字列の右端
		local rightmost = leftmost
		for j = fgRubyPositions[i][1], fgRubyPositions[i][2] do
			rightmost = rightmost + fgCharWidths[j]
		end
		if fgRubyPositions[i][2] < #fgTexts then
			rightmost = rightmost - kerning
		end

		-- ルビ描画
		if fgRubys[i] and fgRubys[i] ~= "" then
			obj.load("text", textPrefix .. fgRubys[i])
			obj.draw((leftmost + rightmost) / 2, rubyY - (textHeight + rubyHeight) / 2)
		end
	end


	-- 前景をキャッシュに退避
	obj.copybuffer("cache:foreground", "tempbuffer")



	---- ガイド描画
	if showGuide then
		obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)
		
		-- 対象メインテキストの左端位置
		startPosition = -textWidth / 2

		-- 変化時間比率描画
		obj.setfont(unpack(FONT_GUIDE))
		position = startPosition
		for i = 1, len do
			obj.load("text", tostring(timeBeats[i]))
			obj.draw(position + (charWidths[i] - ((i < len) and kerning or 0)) / 2, (textHeight + FONT_GUIDE[2]) / 2)
			position = position + charWidths[i]
		end
		obj.load("text", "変化時間比率")
		obj.draw(startPosition + textWidth / 2, (textHeight + FONT_GUIDE[2] * 3) / 2)

		-- ガイドをキャッシュに退避
		obj.copybuffer("cache:guide", "tempbuffer")
	end



	---- 背景と前景とガイドとを合体
	obj.setoption("drawtarget", "tempbuffer", bufferWidth, bufferHeight)


	-- 背景描画
	obj.copybuffer("object", "cache:background")
	obj.effect("クリッピング", "左", bufferWidth / 2 + clipping)
	obj.draw((bufferWidth / 2 + clipping) / 2)


	-- 前景描画
	obj.copybuffer("object", "cache:foreground")
	obj.effect("クリッピング", "右", bufferWidth / 2 - clipping)
	obj.draw(-(bufferWidth / 2 - clipping) / 2)


	-- ガイド描画
	if showGuide then
		obj.copybuffer("object", "cache:guide")
		obj.draw()
	end



	---- 描画・水平配置調整
	obj.load("tempbuffer")
	obj.cx = (textAlign % 3 - 1) * textWidth / 2
	obj.cy = (math.floor(textAlign / 3) - 1) * textHeight / 2
end


main()
